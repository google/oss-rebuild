// Copyright 2025 Google LLC
// SPDX-License-Identifier: Apache-2.0

package stabilize

import (
	"archive/zip"
	"bytes"
	"fmt"
	"io"
	"testing"

	"github.com/google/oss-rebuild/pkg/archive"
)

func TestUnstablePypi(t *testing.T) {
	testCases := []struct {
		test            string
		input           []*archive.ZipEntry
		expected        []*archive.ZipEntry
		pypiStabilizers []Stabilizer
	}{
		{
			test: "**_version.py stabilization (removal)",
			input: []*archive.ZipEntry{
				{FileHeader: &zip.FileHeader{Name: "foo_version.py"}, Body: []byte("print(\"Test Example\")")},
			},
			expected: []*archive.ZipEntry{
				{FileHeader: &zip.FileHeader{Name: "foo_version.py"}, Body: []byte("This needed to change (version file)")},
			},
			pypiStabilizers: []Stabilizer{StableVersionFile2},
		},
		{
			test: "version.py TYPE_CHECKING stabilization (pattern replacement)",
			input: []*archive.ZipEntry{
				{FileHeader: &zip.FileHeader{Name: "package/version.py"}, Body: []byte("# file generated by setuptools_scm\n# don't change, don't track in version control\nTYPE_CHECKING = False\nif TYPE_CHECKING:\n    from typing import Tuple, Union\n    VERSION_TUPLE = Tuple[Union[int, str], ...]\nelse:\n    VERSION_TUPLE = object\n\nversion: str\n__version__: str\n__version_tuple__: VERSION_TUPLE\nversion_tuple: VERSION_TUPLE\n\n__version__ = version = '2.23.4'\n__version_tuple__ = version_tuple = (2, 23, 4)\n")},
			},
			expected: []*archive.ZipEntry{
				{FileHeader: &zip.FileHeader{Name: "package/version.py"}, Body: []byte("# file generated by setuptools_scm\n# don't change, don't track in version control\n\n__all__ = [\"__version__\", \"__version_tuple__\", \"version\", \"version_tuple\"]\n\nTYPE_CHECKING = False\nif TYPE_CHECKING:\n    from typing import Tuple\n    from typing import Union\n\n    VERSION_TUPLE = Tuple[Union[int, str], ...]\nelse:\n    VERSION_TUPLE = object\n\nversion: str\n__version__: str\n__version_tuple__: VERSION_TUPLE\nversion_tuple: VERSION_TUPLE\n\n__version__ = version = '2.23.4'\n__version_tuple__ = version_tuple = (2, 23, 4)\n")},
			},
			pypiStabilizers: []Stabilizer{StableVersionFile},
		},
		{
			test: "crlf stabilization (replacement)",
			input: []*archive.ZipEntry{
				{FileHeader: &zip.FileHeader{Name: "main.py"}, Body: []byte("print(\"Test Example\")\r\nprint(\"Again\")\r\n")},
			},
			expected: []*archive.ZipEntry{
				{FileHeader: &zip.FileHeader{Name: "main.py"}, Body: []byte("print(\"Test Example\")\nprint(\"Again\")\n")},
			},
			pypiStabilizers: []Stabilizer{StableCrlf},
		},
		{
			test: "RECORD stabilization (recalculation)",
			input: []*archive.ZipEntry{
				{FileHeader: &zip.FileHeader{Name: "main.py"}, Body: []byte("print(\"Test Example\")\r\n")},
				{FileHeader: &zip.FileHeader{Name: "RECORD"}, Body: []byte("main.py,sha256=m4Zko9OiLRzzuYT2lK_OqeuQYu8c3SBEQ0OGXfigXaA,23\n")},
			},
			expected: []*archive.ZipEntry{
				{FileHeader: &zip.FileHeader{Name: "main.py"}, Body: []byte("print(\"Test Example\")\n")},
				{FileHeader: &zip.FileHeader{Name: "RECORD"}, Body: []byte("main.py,sha256=JS6wpAIal6Ln6jkjf27iP4mJQFWyNJ4bHzxpxc8a_Gc,22\n")},
			},
			pypiStabilizers: []Stabilizer{StableCrlf, StablePypiRecord},
		},
	}
	for _, tc := range testCases {
		t.Run(tc.test, func(t *testing.T) {
			// Construct zip from tc.input
			var input bytes.Buffer
			{
				zw := zip.NewWriter(&input)
				for _, entry := range tc.input {
					orDie(entry.WriteTo(zw))
				}
				orDie(zw.Close())
			}
			var output bytes.Buffer
			zr := must(zip.NewReader(bytes.NewReader(input.Bytes()), int64(input.Len())))

			err := StabilizeZip(zr, zip.NewWriter(&output), StabilizeOpts{Stabilizers: tc.pypiStabilizers})
			if err != nil {
				t.Fatalf("StabilizeZip(%v) = %v, want nil", tc.test, err)
			}
			var got []archive.ZipEntry
			{
				zr := must(zip.NewReader(bytes.NewReader(output.Bytes()), int64(output.Len())))
				for _, ent := range zr.File {
					got = append(got, archive.ZipEntry{FileHeader: &ent.FileHeader, Body: must(io.ReadAll(must(ent.Open())))})
				}
			}
			if len(got) != len(tc.expected) {
				t.Fatalf("StabilizeZip(%v) = %v, want %v", tc.test, got, tc.expected)
			}
			for i := range got {
				test1 := got[i].FileHeader.Name == tc.expected[i].FileHeader.Name
				test2 := bytes.Equal(got[i].Body, tc.expected[i].Body)
				test3 := got[i].FileHeader.Modified.Equal(tc.expected[i].FileHeader.Modified)
				test4 := got[i].FileHeader.Comment == tc.expected[i].FileHeader.Comment
				test5 := string(got[i].Body)
				test6 := string(tc.expected[i].Body)
				if !test2 {
					fmt.Printf("%v, %v, %v, %v", test1, test2, test3, test4)
					fmt.Printf("\nCaptured File:\n[%v]\n", test5)
					fmt.Printf("\nExpected File:\n[%v]\n", test6)
				}
				if !all(
					got[i].FileHeader.Name == tc.expected[i].FileHeader.Name,
					bytes.Equal(got[i].Body, tc.expected[i].Body),
				) {
					t.Fatalf("StabilizeZip(%v) = %v, want %v", tc.test, got, tc.expected)
				}
			}
		})
	}
}
